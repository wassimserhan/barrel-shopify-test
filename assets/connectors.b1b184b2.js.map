{"version":3,"file":"connectors.b1b184b2.js","sources":["../modules/plp--complex/lib/connectors.js"],"sourcesContent":["import nano from 'nanoajax'\n\nimport {\n  parseJSON,\n  decodeCollectionMeta,\n  calculateFilters\n} from './util'\n\n/**\n * Called directly by the Redux action. This\n * sets up the promise chain that returns the data\n * from all pages that need to be requested. This\n * is important when a collection has more than\n * 50 products, like the /collections/all collection\n *\n * @param {function} getState - Gets the current Redux state\n * @param {function} cb - Callback function to call when it's all over\n */\nexport const getData = (getState, cb) => {\n  const {\n    collection,\n    sort\n  } = getState()\n  getAllCollectionPages(collection, sort).then(data => {\n    const filters = calculateFilters(data)\n    data = {...data, ...{filters}}\n    cb(data)\n  }).catch(e => {\n    console.log(e)\n  })\n}\n\n/**\n * Sets up a promise chain to get all pages of products.\n * First, we fire a request for page 1 to see how many pages\n * we need to get. Then, we set up a Promise.all to get\n * all the other pages at the same time.\n *\n * @param {string} collection - The collection handle used in the URL\n * @param {string} sort - The current sort value\n */\nconst getAllCollectionPages = (collection, sort) => {\n  return getCollection(collection, sort, 1).then(data => {\n    let {pages} = data\n    pages = Number(pages)\n\n    if (pages > 1) {\n      const iterations = [...Array(pages - 1).keys()]\n      const chain = iterations.map(i => (\n        getCollection(collection, sort, (i + 2))\n      ))\n\n      return Promise.all(chain).then(responses => {\n        responses.forEach(res => {\n          data.variants = [...data.variants, ...res.variants]\n        })\n\n        return Promise.resolve(data)\n      })\n    } else {\n      return Promise.resolve(data)\n    }\n  })\n}\n\n/**\n * Fires the actual ajax request to get the json from shopify.\n * Wraps this in a promise so we can chain onto it after it\n * completes\n *\n * @param {string} collection - The collection handle used in the URL\n * @param {string} sort - The current sort value\n * @param {int} page - The page of paginated results to return\n */\nconst getCollection = (collection, sort, page) => {\n  return new Promise((resolve, reject) => {\n    nano.ajax(\n      {url: `${collection}?view=plp-endpoint&sort_by=${sort}&page=${page}`},\n      (code, res) => {\n        res = parseJSON(res)\n        res.meta && decodeCollectionMeta(res.meta)\n        resolve(res)\n      }\n    )\n  })\n}\n"],"names":["getData","getState","cb","collection","sort","getAllCollectionPages","data","filters","calculateFilters","e","getCollection","pages","chain","i","responses","res","page","resolve","reject","nano","code","parseJSON","decodeCollectionMeta"],"mappings":"8KAkBY,MAACA,EAAU,CAACC,EAAUC,IAAO,CACvC,KAAM,CACJ,WAAAC,EACA,KAAAC,CACD,EAAGH,EAAU,EACdI,EAAsBF,EAAYC,CAAI,EAAE,KAAKE,GAAQ,CACnD,MAAMC,EAAUC,EAAiBF,CAAI,EACrCA,EAAO,CAAC,GAAGA,EAAU,QAAAC,CAAQ,EAC7BL,EAAGI,CAAI,CACX,CAAG,EAAE,MAAMG,GAAK,CACZ,QAAQ,IAAIA,CAAC,CACjB,CAAG,CACH,EAWMJ,EAAwB,CAACF,EAAYC,IAClCM,EAAcP,EAAYC,EAAM,CAAC,EAAE,KAAKE,GAAQ,CACrD,GAAI,CAAC,MAAAK,CAAK,EAAIL,EAGd,GAFAK,EAAQ,OAAOA,CAAK,EAEhBA,EAAQ,EAAG,CAEb,MAAMC,EADa,CAAC,GAAG,MAAMD,EAAQ,CAAC,EAAE,MAAM,EACrB,IAAIE,GAC3BH,EAAcP,EAAYC,EAAOS,EAAI,CAAG,CACzC,EAED,OAAO,QAAQ,IAAID,CAAK,EAAE,KAAKE,IAC7BA,EAAU,QAAQC,GAAO,CACvBT,EAAK,SAAW,CAAC,GAAGA,EAAK,SAAU,GAAGS,EAAI,QAAQ,CAC5D,CAAS,EAEM,QAAQ,QAAQT,CAAI,EAC5B,CACP,KACM,QAAO,QAAQ,QAAQA,CAAI,CAEjC,CAAG,EAYGI,EAAgB,CAACP,EAAYC,EAAMY,IAChC,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtCC,EAAK,KACH,CAAC,IAAK,GAAGhB,+BAAwCC,UAAaY,GAAM,EACpE,CAACI,EAAML,IAAQ,CACbA,EAAMM,EAAUN,CAAG,EACnBA,EAAI,MAAQO,EAAqBP,EAAI,IAAI,EACzCE,EAAQF,CAAG,CACZ,CACF,CACL,CAAG"}